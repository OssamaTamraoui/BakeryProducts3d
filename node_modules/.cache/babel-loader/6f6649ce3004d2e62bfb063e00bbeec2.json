{"ast":null,"code":"import * as THREE from \"three\";\nimport { SPACE_SIZE } from \"../Viewer3DConstants\";\n\nfunction ShadowPlane() {\n  const geometry = new THREE.PlaneGeometry(SPACE_SIZE, SPACE_SIZE);\n  geometry.rotateX(-Math.PI / 2);\n  const material = new THREE.ShadowMaterial();\n  material.opacity = 0.3;\n  const groundMesh = new THREE.Mesh(geometry, material);\n  groundMesh.name = \"GroundMesh\";\n  groundMesh.position.y = 0;\n  groundMesh.receiveShadow = true;\n  return groundMesh;\n}\n\n_c = ShadowPlane;\n\nfunction FitCameraToSelection(camera, object, offset, controls) {\n  offset = offset || 1.25;\n  const boundingBox = new THREE.Box3(); // get bounding box of object - this will be used to setup controls and camera\n\n  boundingBox.setFromObject(object);\n  const center = new THREE.Vector3();\n  boundingBox.getCenter(center);\n  const size = new THREE.Vector3();\n  boundingBox.getSize(size); // get the max side of the bounding box (fits to width OR height as needed )\n\n  const maxDim = Math.max(size.x, size.y, size.z);\n  var cameraZ = Math.abs(maxDim / 4);\n  cameraZ *= offset; // zoom out a little so that objects don't fill the screen\n\n  camera.position.z = cameraZ;\n  const minZ = boundingBox.min.z;\n  const cameraToFarEdge = minZ < 0 ? -minZ + cameraZ : cameraZ - minZ;\n  camera.far = cameraToFarEdge * 3;\n  camera.updateProjectionMatrix();\n\n  if (controls) {\n    // set camera to rotate around center of loaded object\n    controls.target = center; // prevent camera from zooming out far enough to create far plane cutoff\n\n    controls.maxDistance = cameraToFarEdge * 2;\n  } else {\n    camera.lookAt(center);\n  }\n}\n\n_c2 = FitCameraToSelection;\nexport { ShadowPlane, FitCameraToSelection };\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ShadowPlane\");\n$RefreshReg$(_c2, \"FitCameraToSelection\");","map":{"version":3,"names":["THREE","SPACE_SIZE","ShadowPlane","geometry","PlaneGeometry","rotateX","Math","PI","material","ShadowMaterial","opacity","groundMesh","Mesh","name","position","y","receiveShadow","FitCameraToSelection","camera","object","offset","controls","boundingBox","Box3","setFromObject","center","Vector3","getCenter","size","getSize","maxDim","max","x","z","cameraZ","abs","minZ","min","cameraToFarEdge","far","updateProjectionMatrix","target","maxDistance","lookAt"],"sources":["/Users/sam/Documents/CakeProject/src/components/Viewer3D/libs/Helpers.js"],"sourcesContent":["import * as THREE from \"three\"\nimport {SPACE_SIZE} from \"../Viewer3DConstants\"\n\nfunction ShadowPlane() {\n  const geometry = new THREE.PlaneGeometry(SPACE_SIZE, SPACE_SIZE)\n  geometry.rotateX(-Math.PI / 2)\n  const material = new THREE.ShadowMaterial()\n  material.opacity = 0.3\n  const groundMesh = new THREE.Mesh(geometry, material)\n  groundMesh.name = \"GroundMesh\"\n  groundMesh.position.y = 0\n  groundMesh.receiveShadow = true\n  return groundMesh\n}\n\nfunction FitCameraToSelection(camera, object, offset, controls) {\n  offset = offset || 1.25\n\n  const boundingBox = new THREE.Box3()\n\n  // get bounding box of object - this will be used to setup controls and camera\n  boundingBox.setFromObject(object)\n\n  const center = new THREE.Vector3()\n\n  boundingBox.getCenter(center)\n\n  const size = new THREE.Vector3()\n  boundingBox.getSize(size)\n\n  // get the max side of the bounding box (fits to width OR height as needed )\n  const maxDim = Math.max(size.x, size.y, size.z)\n\n  var cameraZ = Math.abs(maxDim / 4)\n\n  cameraZ *= offset // zoom out a little so that objects don't fill the screen\n\n  camera.position.z = cameraZ\n\n  const minZ = boundingBox.min.z\n  const cameraToFarEdge = minZ < 0 ? -minZ + cameraZ : cameraZ - minZ\n\n  camera.far = cameraToFarEdge * 3\n  camera.updateProjectionMatrix()\n\n  if (controls) {\n    // set camera to rotate around center of loaded object\n    controls.target = center\n    // prevent camera from zooming out far enough to create far plane cutoff\n    controls.maxDistance = cameraToFarEdge * 2\n  } else {\n    camera.lookAt(center)\n  }\n}\n\nexport {ShadowPlane, FitCameraToSelection}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAAQC,UAAR,QAAyB,sBAAzB;;AAEA,SAASC,WAAT,GAAuB;EACrB,MAAMC,QAAQ,GAAG,IAAIH,KAAK,CAACI,aAAV,CAAwBH,UAAxB,EAAoCA,UAApC,CAAjB;EACAE,QAAQ,CAACE,OAAT,CAAiB,CAACC,IAAI,CAACC,EAAN,GAAW,CAA5B;EACA,MAAMC,QAAQ,GAAG,IAAIR,KAAK,CAACS,cAAV,EAAjB;EACAD,QAAQ,CAACE,OAAT,GAAmB,GAAnB;EACA,MAAMC,UAAU,GAAG,IAAIX,KAAK,CAACY,IAAV,CAAeT,QAAf,EAAyBK,QAAzB,CAAnB;EACAG,UAAU,CAACE,IAAX,GAAkB,YAAlB;EACAF,UAAU,CAACG,QAAX,CAAoBC,CAApB,GAAwB,CAAxB;EACAJ,UAAU,CAACK,aAAX,GAA2B,IAA3B;EACA,OAAOL,UAAP;AACD;;KAVQT,W;;AAYT,SAASe,oBAAT,CAA8BC,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EAAsDC,QAAtD,EAAgE;EAC9DD,MAAM,GAAGA,MAAM,IAAI,IAAnB;EAEA,MAAME,WAAW,GAAG,IAAItB,KAAK,CAACuB,IAAV,EAApB,CAH8D,CAK9D;;EACAD,WAAW,CAACE,aAAZ,CAA0BL,MAA1B;EAEA,MAAMM,MAAM,GAAG,IAAIzB,KAAK,CAAC0B,OAAV,EAAf;EAEAJ,WAAW,CAACK,SAAZ,CAAsBF,MAAtB;EAEA,MAAMG,IAAI,GAAG,IAAI5B,KAAK,CAAC0B,OAAV,EAAb;EACAJ,WAAW,CAACO,OAAZ,CAAoBD,IAApB,EAb8D,CAe9D;;EACA,MAAME,MAAM,GAAGxB,IAAI,CAACyB,GAAL,CAASH,IAAI,CAACI,CAAd,EAAiBJ,IAAI,CAACb,CAAtB,EAAyBa,IAAI,CAACK,CAA9B,CAAf;EAEA,IAAIC,OAAO,GAAG5B,IAAI,CAAC6B,GAAL,CAASL,MAAM,GAAG,CAAlB,CAAd;EAEAI,OAAO,IAAId,MAAX,CApB8D,CAoB5C;;EAElBF,MAAM,CAACJ,QAAP,CAAgBmB,CAAhB,GAAoBC,OAApB;EAEA,MAAME,IAAI,GAAGd,WAAW,CAACe,GAAZ,CAAgBJ,CAA7B;EACA,MAAMK,eAAe,GAAGF,IAAI,GAAG,CAAP,GAAW,CAACA,IAAD,GAAQF,OAAnB,GAA6BA,OAAO,GAAGE,IAA/D;EAEAlB,MAAM,CAACqB,GAAP,GAAaD,eAAe,GAAG,CAA/B;EACApB,MAAM,CAACsB,sBAAP;;EAEA,IAAInB,QAAJ,EAAc;IACZ;IACAA,QAAQ,CAACoB,MAAT,GAAkBhB,MAAlB,CAFY,CAGZ;;IACAJ,QAAQ,CAACqB,WAAT,GAAuBJ,eAAe,GAAG,CAAzC;EACD,CALD,MAKO;IACLpB,MAAM,CAACyB,MAAP,CAAclB,MAAd;EACD;AACF;;MAtCQR,oB;AAwCT,SAAQf,WAAR,EAAqBe,oBAArB"},"metadata":{},"sourceType":"module"}