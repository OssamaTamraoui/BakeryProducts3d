{"ast":null,"code":"import { CubeUVReflectionMapping, GammaEncoding, LinearEncoding, NoToneMapping, NearestFilter, NoBlending, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBM16Encoding, RGBM7Encoding, UnsignedByteType, sRGBEncoding } from '../constants.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { RawShaderMaterial } from '../materials/RawShaderMaterial.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { BackSide } from '../constants.js';\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nconst MAX_SAMPLES = 20;\nconst ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\nconst backgroundMaterial = new MeshBasicMaterial({\n  side: BackSide,\n  depthWrite: false,\n  depthTest: false\n});\nconst backgroundBox = new Mesh(new BoxBufferGeometry(), backgroundMaterial);\n\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\nconst {\n  _lodPlanes,\n  _sizeLods,\n  _sigmas\n} = /*@__PURE__*/_createPlanes();\n\nconst _clearColor = /*@__PURE__*/new Color();\n\nlet _oldTarget = null; // Golden Ratio\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nfunction convertLinearToRGBE(color) {\n  const maxComponent = Math.max(color.r, color.g, color.b);\n  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n  color.multiplyScalar(Math.pow(2.0, -fExp));\n  const alpha = (fExp + 128.0) / 255.0;\n  return alpha;\n}\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  fromScene(scene) {\n    let sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromEquirectangular(equirectangular) {\n    return this._fromTexture(equirectangular);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromCubemap(cubemap) {\n    return this._fromTexture(cubemap);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n\n\n  dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._cubemapShader !== null) this._cubemapShader.dispose();\n    if (this._equirectShader !== null) this._equirectShader.dispose();\n\n    for (let i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  } // private interface\n\n\n  _cleanup(outputTarget) {\n    this._pingPongRenderTarget.dispose();\n\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = this._allocateTargets(texture);\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets(texture) {\n    // warning: null texture is valid\n    const params = {\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      generateMipmaps: false,\n      type: UnsignedByteType,\n      format: RGBEFormat,\n      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n      depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(params);\n\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n    this._pingPongRenderTarget = _createRenderTarget(params);\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(_lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    renderer.autoClear = false;\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background).convertSRGBToLinear();\n        scene.background = null;\n        const alpha = convertLinearToRGBE(backgroundMaterial.color);\n        backgroundMaterial.opacity = alpha;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n      const alpha = convertLinearToRGBE(backgroundMaterial.color);\n      backgroundMaterial.opacity = alpha;\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n\n      if (col == 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col == 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    renderer.autoClear = originalAutoClear;\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n\n    if (texture.isCubeTexture) {\n      if (this._cubemapShader == null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n    } else {\n      if (this._equirectShader == null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n\n    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n    const mesh = new Mesh(_lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n\n    if (!texture.isCubeTexture) {\n      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n    }\n\n    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < TOTAL_LODS; i++) {\n      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = _sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(\"sigmaRadians, \".concat(sigmaRadians, \", is too large and will clip, as it requested \").concat(samples, \" samples when the maximum is set to \").concat(MAX_SAMPLES));\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    const outputSize = _sizeLods[lodOut];\n    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n\n}\n\nfunction _isLDR(texture) {\n  if (texture === undefined || texture.type !== UnsignedByteType) return false;\n  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n}\n\nfunction _createPlanes() {\n  const _lodPlanes = [];\n  const _sizeLods = [];\n  const _sigmas = [];\n  let lod = LOD_MAX;\n\n  for (let i = 0; i < TOTAL_LODS; i++) {\n    const sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    let sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    const texelSize = 1.0 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes,\n    _sizeLods,\n    _sigmas\n  };\n}\n\nfunction _createRenderTarget(params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(maxSamples) {\n  const weights = new Float32Array(maxSamples);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform int samples;\\n\\t\\t\\tuniform float weights[ n ];\\n\\t\\t\\tuniform bool latitudinal;\\n\\t\\t\\tuniform float dTheta;\\n\\t\\t\\tuniform float mipInt;\\n\\t\\t\\tuniform vec3 poleAxis;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t#include <cube_uv_reflection_fragment>\\n\\n\\t\\t\\tvec3 getSample( float theta, vec3 axis ) {\\n\\n\\t\\t\\t\\tfloat cosTheta = cos( theta );\\n\\t\\t\\t\\t// Rodrigues' axis-angle rotation\\n\\t\\t\\t\\tvec3 sampleDirection = vOutputDirection * cosTheta\\n\\t\\t\\t\\t\\t+ cross( axis, vOutputDirection ) * sin( theta )\\n\\t\\t\\t\\t\\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\\n\\n\\t\\t\\t\\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\\n\\n\\t\\t\\t\\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\\n\\n\\t\\t\\t\\t\\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taxis = normalize( axis );\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\\n\\n\\t\\t\\t\\tfor ( int i = 1; i < n; i++ ) {\\n\\n\\t\\t\\t\\t\\tif ( i >= samples ) {\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfloat theta = dTheta * float( i );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  const texelSize = new Vector2(1, 1);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform vec2 texelSize;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\t#include <common>\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\n\\t\\t\\t\\tvec3 outputDirection = normalize( vOutputDirection );\\n\\t\\t\\t\\tvec2 uv = equirectUv( outputDirection );\\n\\n\\t\\t\\t\\tvec2 f = fract( uv / texelSize - 0.5 );\\n\\t\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\t\\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x += texelSize.x;\\n\\t\\t\\t\\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.y += texelSize.y;\\n\\t\\t\\t\\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x -= texelSize.x;\\n\\t\\t\\t\\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\n\\t\\t\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\t\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\t\\t\\tgl_FragColor.rgb = mix( tm, bm, f.y );\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform samplerCube envMap;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    \"\\n\\n\\t\\tprecision mediump float;\\n\\t\\tprecision mediump int;\\n\\n\\t\\tattribute vec3 position;\\n\\t\\tattribute vec2 uv;\\n\\t\\tattribute float faceIndex;\\n\\n\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t// RH coordinate system; PMREM face-indexing convention\\n\\t\\tvec3 getDirection( vec2 uv, float face ) {\\n\\n\\t\\t\\tuv = 2.0 * uv - 1.0;\\n\\n\\t\\t\\tvec3 direction = vec3( uv, 1.0 );\\n\\n\\t\\t\\tif ( face == 0.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx; // ( 1, v, u ) pos x\\n\\n\\t\\t\\t} else if ( face == 1.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\\n\\n\\t\\t\\t} else if ( face == 2.0 ) {\\n\\n\\t\\t\\t\\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\\n\\n\\t\\t\\t} else if ( face == 3.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\\n\\n\\t\\t\\t} else if ( face == 4.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\\n\\n\\t\\t\\t} else if ( face == 5.0 ) {\\n\\n\\t\\t\\t\\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn direction;\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvOutputDirection = getDirection( uv, faceIndex );\\n\\t\\t\\tgl_Position = vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\t\"\n  );\n}\n\nfunction _getEncodings() {\n  return (\n    /* glsl */\n    \"\\n\\n\\t\\tuniform int inputEncoding;\\n\\t\\tuniform int outputEncoding;\\n\\n\\t\\t#include <encodings_pars_fragment>\\n\\n\\t\\tvec4 inputTexelToLinear( vec4 value ) {\\n\\n\\t\\t\\tif ( inputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( inputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn sRGBToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn RGBEToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 7.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 16.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn RGBDToLinear( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn GammaToLinear( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 linearToOutputTexel( vec4 value ) {\\n\\n\\t\\t\\tif ( outputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( outputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn LinearTosRGB( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBE( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 7.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 16.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBD( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn LinearToGamma( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 envMapTexelToLinear( vec4 color ) {\\n\\n\\t\\t\\treturn inputTexelToLinear( color );\\n\\n\\t\\t}\\n\\t\"\n  );\n}\n\nexport { PMREMGenerator };","map":{"version":3,"names":["CubeUVReflectionMapping","GammaEncoding","LinearEncoding","NoToneMapping","NearestFilter","NoBlending","RGBDEncoding","RGBEEncoding","RGBEFormat","RGBM16Encoding","RGBM7Encoding","UnsignedByteType","sRGBEncoding","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","RawShaderMaterial","Vector2","Vector3","Color","WebGLRenderTarget","MeshBasicMaterial","BoxBufferGeometry","BackSide","LOD_MIN","LOD_MAX","SIZE_MAX","Math","pow","EXTRA_LOD_SIGMA","TOTAL_LODS","length","MAX_SAMPLES","ENCODINGS","backgroundMaterial","side","depthWrite","depthTest","backgroundBox","_flatCamera","_lodPlanes","_sizeLods","_sigmas","_createPlanes","_clearColor","_oldTarget","PHI","sqrt","INV_PHI","_axisDirections","convertLinearToRGBE","color","maxComponent","max","r","g","b","fExp","min","ceil","log2","multiplyScalar","alpha","PMREMGenerator","constructor","renderer","_renderer","_pingPongRenderTarget","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_compileMaterial","fromScene","scene","sigma","near","far","getRenderTarget","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","dispose","i","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","texture","_textureToCubeUV","params","magFilter","minFilter","generateMipmaps","type","format","encoding","_isLDR","depthBuffer","_createRenderTarget","material","tmpMesh","compile","fov","aspect","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","outputEncoding","toneMapping","getClearColor","useSolidColor","background","isColor","copy","convertSRGBToLinear","opacity","col","up","set","lookAt","render","isCubeTexture","mesh","uniforms","value","image","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","floor","warn","weights","sum","x","weight","exp","push","outputSize","y","undefined","lod","sizeLod","texelSize","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","coordinates","fill","planes","setAttribute","mapping","name","target","viewport","scissor","maxSamples","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","_getEncodings","blending"],"sources":["/Users/sam/Documents/CakeProject/node_modules/three/src/extras/PMREMGenerator.js"],"sourcesContent":["import {\n\tCubeUVReflectionMapping,\n\tGammaEncoding,\n\tLinearEncoding,\n\tNoToneMapping,\n\tNearestFilter,\n\tNoBlending,\n\tRGBDEncoding,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBM16Encoding,\n\tRGBM7Encoding,\n\tUnsignedByteType,\n\tsRGBEncoding\n} from '../constants.js';\n\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { RawShaderMaterial } from '../materials/RawShaderMaterial.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { BackSide } from '../constants.js';\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow( 2, LOD_MAX );\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nconst backgroundMaterial = new MeshBasicMaterial( {\n\tside: BackSide,\n\tdepthWrite: false,\n\tdepthTest: false,\n} );\nconst backgroundBox = new Mesh( new BoxBufferGeometry(), backgroundMaterial );\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nfunction convertLinearToRGBE( color ) {\n\n\tconst maxComponent = Math.max( color.r, color.g, color.b );\n\tconst fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\tcolor.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\n\tconst alpha = ( fExp + 128.0 ) / 255.0;\n\treturn alpha;\n\n}\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._blurMaterial = _getBlurShader( MAX_SAMPLES );\n\t\tthis._equirectShader = null;\n\t\tthis._cubemapShader = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular ) {\n\n\t\treturn this._fromTexture( equirectangular );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap ) {\n\n\t\treturn this._fromTexture( cubemap );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapShader === null ) {\n\n\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\tthis._compileMaterial( this._cubemapShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectShader === null ) {\n\n\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\tthis._compileMaterial( this._equirectShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._blurMaterial.dispose();\n\n\t\tif ( this._cubemapShader !== null ) this._cubemapShader.dispose();\n\t\tif ( this._equirectShader !== null ) this._equirectShader.dispose();\n\n\t\tfor ( let i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._pingPongRenderTarget.dispose();\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets( texture );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets( texture ) { // warning: null texture is valid\n\n\t\tconst params = {\n\t\t\tmagFilter: NearestFilter,\n\t\t\tminFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: UnsignedByteType,\n\t\t\tformat: RGBEFormat,\n\t\t\tencoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( params );\n\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\tthis._pingPongRenderTarget = _createRenderTarget( params );\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( _lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst outputEncoding = renderer.outputEncoding;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputEncoding = LinearEncoding;\n\t\trenderer.autoClear = false;\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background ).convertSRGBToLinear();\n\t\t\t\tscene.background = null;\n\n\t\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();\n\n\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\t\t\tif ( col == 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col == 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\t_setViewport( cubeUVRenderTarget,\n\t\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputEncoding = outputEncoding;\n\t\trenderer.autoClear = originalAutoClear;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( this._cubemapShader == null ) {\n\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectShader == null ) {\n\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\tconst mesh = new Mesh( _lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tif ( ! texture.isCubeTexture ) {\n\n\t\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t\t}\n\n\t\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\t\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = _sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i == 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\t\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\t\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\t\tconst outputSize = _sizeLods[ lodOut ];\n\t\tconst x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\t\tconst y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _isLDR( texture ) {\n\n\tif ( texture === undefined || texture.type !== UnsignedByteType ) return false;\n\n\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\n}\n\nfunction _createPlanes() {\n\n\tconst _lodPlanes = [];\n\tconst _sizeLods = [];\n\tconst _sigmas = [];\n\n\tlet lod = LOD_MAX;\n\n\tfor ( let i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\t_sigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 1 );\n\t\tconst min = - texelSize / 2;\n\t\tconst max = 1 + texelSize / 2;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tconst weights = new Float32Array( maxSamples );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tconst texelSize = new Vector2( 1, 1 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn /* glsl */`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}