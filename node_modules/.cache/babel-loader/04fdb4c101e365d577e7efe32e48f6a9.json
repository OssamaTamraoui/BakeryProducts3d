{"ast":null,"code":"import { Camera } from './Camera.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nfunction PerspectiveCamera() {\n  let fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  let aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n  let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;\n  Camera.call(this);\n  this.type = 'PerspectiveCamera';\n  this.fov = fov;\n  this.zoom = 1;\n  this.near = near;\n  this.far = far;\n  this.focus = 10;\n  this.aspect = aspect;\n  this.view = null;\n  this.filmGauge = 35; // width of the film (default in millimeters)\n\n  this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n  this.updateProjectionMatrix();\n}\n\nPerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {\n  constructor: PerspectiveCamera,\n  isPerspectiveCamera: true,\n  copy: function copy(source, recursive) {\n    Camera.prototype.copy.call(this, source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  },\n\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength: function setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  },\n\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n  getFocalLength: function getFocalLength() {\n    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  },\n  getEffectiveFOV: function getEffectiveFOV() {\n    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n  },\n  getFilmWidth: function getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  },\n  getFilmHeight: function getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  },\n\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n  setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  },\n  clearViewOffset: function clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  },\n  updateProjectionMatrix: function updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n            fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  },\n  toJSON: function toJSON(meta) {\n    const data = Object3D.prototype.toJSON.call(this, meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n});\nexport { PerspectiveCamera };","map":{"version":3,"names":["Camera","Object3D","MathUtils","PerspectiveCamera","fov","aspect","near","far","call","type","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","prototype","Object","assign","create","constructor","isPerspectiveCamera","copy","source","recursive","setFocalLength","focalLength","vExtentSlope","getFilmHeight","RAD2DEG","Math","atan","getFocalLength","tan","DEG2RAD","getEffectiveFOV","getFilmWidth","min","max","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","projectionMatrix","makePerspective","projectionMatrixInverse","invert","toJSON","meta","data","object"],"sources":["/Users/sam/Documents/CakeProject/node_modules/three/src/cameras/PerspectiveCamera.js"],"sourcesContent":["import { Camera } from './Camera.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nfunction PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov;\n\tthis.zoom = 1;\n\n\tthis.near = near;\n\tthis.far = far;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n}\n\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: PerspectiveCamera,\n\n\tisPerspectiveCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tconst data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n\nexport { PerspectiveCamera };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}