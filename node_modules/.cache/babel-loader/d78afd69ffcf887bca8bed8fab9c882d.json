{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\nlet _id = 0;\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nconst _box = new Box3();\n\nconst _boxMorphTargets = new Box3();\n\nconst _vector = new Vector3();\n\nfunction BufferGeometry() {\n  Object.defineProperty(this, 'id', {\n    value: _id++\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = 'BufferGeometry';\n  this.index = null;\n  this.attributes = {};\n  this.morphAttributes = {};\n  this.morphTargetsRelative = false;\n  this.groups = [];\n  this.boundingBox = null;\n  this.boundingSphere = null;\n  this.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n  this.userData = {};\n}\n\nBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: BufferGeometry,\n  isBufferGeometry: true,\n  getIndex: function getIndex() {\n    return this.index;\n  },\n  setIndex: function setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n\n    return this;\n  },\n  getAttribute: function getAttribute(name) {\n    return this.attributes[name];\n  },\n  setAttribute: function setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  },\n  deleteAttribute: function deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  },\n  hasAttribute: function hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  },\n  addGroup: function addGroup(start, count) {\n    let materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  },\n  clearGroups: function clearGroups() {\n    this.groups = [];\n  },\n  setDrawRange: function setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  },\n  applyMatrix4: function applyMatrix4(matrix) {\n    const position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    const normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    const tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  rotateX: function rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateY: function rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateZ: function rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  translate: function translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  scale: function scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  lookAt: function lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  setFromPoints: function setFromPoints(points) {\n    const position = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n\n            this.boundingBox.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox.max, _box.max);\n\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      const center = this.boundingSphere.center;\n\n      _box.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  },\n  computeFaceNormals: function computeFaceNormals() {// backwards compatibility\n  },\n  computeTangents: function computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n    const nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    const tangents = attributes.tangent.array;\n    const tan1 = [],\n          tan2 = [];\n\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    const vA = new Vector3(),\n          vB = new Vector3(),\n          vC = new Vector3(),\n          uvA = new Vector2(),\n          uvB = new Vector2(),\n          uvC = new Vector2(),\n          sdir = new Vector3(),\n          tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    let groups = this.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    const tmp = new Vector3(),\n          tmp2 = new Vector3();\n    const n = new Vector3(),\n          n2 = new Vector3();\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      const t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      const pA = new Vector3(),\n            pB = new Vector3(),\n            pC = new Vector3();\n      const nA = new Vector3(),\n            nB = new Vector3(),\n            nC = new Vector3();\n      const cb = new Vector3(),\n            ab = new Vector3(); // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  },\n  merge: function merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      const attribute1 = attributes[key];\n      const attributeArray1 = attribute1.array;\n      const attribute2 = geometry.attributes[key];\n      const attributeArray2 = attribute2.array;\n      const attributeOffset = attribute2.itemSize * offset;\n      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  },\n  normalizeNormals: function normalizeNormals() {\n    const normals = this.attributes.normal;\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  },\n  toNonIndexed: function toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize, normalized);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes; // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    const morphAttributes = this.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    const groups = this.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  },\n  toJSON: function toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    } // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    const groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    const boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  },\n  clone: function clone() {\n    /*\n     // Handle primitives\n    \t const parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t const values = [];\n    \t for ( const key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t const geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new BufferGeometry().copy(this);\n  },\n  copy: function copy(source) {\n    // reset\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // used for storing cloned, shared data\n\n    const data = {}; // name\n\n    this.name = source.name; // index\n\n    const index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    } // attributes\n\n\n    const attributes = source.attributes;\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    } // morph attributes\n\n\n    const morphAttributes = source.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    const groups = source.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { BufferGeometry };","map":{"version":3,"names":["Vector3","Vector2","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","Object3D","Matrix4","Matrix3","MathUtils","arrayMax","_id","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","Object","defineProperty","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","prototype","assign","create","constructor","isBufferGeometry","getIndex","setIndex","Array","isArray","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","i","l","length","point","morphAttributesPosition","isGLBufferAttribute","console","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeFaceNormals","computeTangents","uv","indices","array","positions","normals","uvs","nVertices","Float32Array","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","test","w","computeVertexNormals","positionAttribute","normalAttribute","setXYZ","pA","pB","pC","nA","nB","nC","cb","ab","getX","subVectors","cross","normalizeNormals","merge","geometry","offset","warn","key","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","toNonIndexed","convertBufferAttribute","normalized","array2","index2","geometry2","newAttribute","morphArray","toJSON","data","metadata","version","generator","keys","parameters","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","clone","source","dispose","dispatchEvent"],"sources":["/Users/sam/Documents/CakeProject/node_modules/three/src/core/BufferGeometry.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\n\nlet _id = 0;\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nconst _box = new Box3();\nconst _boxMorphTargets = new Box3();\nconst _vector = new Vector3();\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\tthis.morphTargetsRelative = false;\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tsetAttribute: function ( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tdeleteAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\thasAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = attributes.tangent.array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tconst attribute1 = attributes[ key ];\n\t\t\tconst attributeArray1 = attribute1.array;\n\n\t\t\tconst attribute2 = geometry.attributes[ key ];\n\t\t\tconst attributeArray2 = attribute2.array;\n\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { BufferGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}