{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = new Matrix4();\n\nconst _ray = new Ray();\n\nconst _sphere = new Sphere();\n\nconst _vA = new Vector3();\n\nconst _vB = new Vector3();\n\nconst _vC = new Vector3();\n\nconst _tempA = new Vector3();\n\nconst _tempB = new Vector3();\n\nconst _tempC = new Vector3();\n\nconst _morphA = new Vector3();\n\nconst _morphB = new Vector3();\n\nconst _morphC = new Vector3();\n\nconst _uvA = new Vector2();\n\nconst _uvB = new Vector2();\n\nconst _uvC = new Vector2();\n\nconst _intersectionPoint = new Vector3();\n\nconst _intersectionPointWorld = new Vector3();\n\nfunction Mesh() {\n  let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n  let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();\n  Object3D.call(this);\n  this.type = 'Mesh';\n  this.geometry = geometry;\n  this.material = material;\n  this.updateMorphTargets();\n}\n\nMesh.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: Mesh,\n  isMesh: true,\n  copy: function copy(source) {\n    Object3D.prototype.copy.call(this, source);\n\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  },\n  updateMorphTargets: function updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  },\n  raycast: function raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n    if (geometry.boundingBox !== null) {\n      if (_ray.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    let intersection;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n});\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA.fromBufferAttribute(position, a);\n\n  _vB.fromBufferAttribute(position, b);\n\n  _vC.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (material.morphTargets && morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n\n    _vA.add(_morphA);\n\n    _vB.add(_morphB);\n\n    _vC.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh && material.skinning) {\n    object.boneTransform(a, _vA);\n    object.boneTransform(b, _vB);\n    object.boneTransform(c, _vC);\n  }\n\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n\n      _uvB.fromBufferAttribute(uv, b);\n\n      _uvC.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n\n      _uvB.fromBufferAttribute(uv2, b);\n\n      _uvC.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nexport { Mesh };","map":{"version":3,"names":["Vector3","Vector2","Sphere","Ray","Matrix4","Object3D","Triangle","DoubleSide","BackSide","MeshBasicMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA","_uvB","_uvC","_intersectionPoint","_intersectionPointWorld","Mesh","geometry","material","call","type","updateMorphTargets","prototype","Object","assign","create","constructor","isMesh","copy","source","morphTargetInfluences","undefined","slice","morphTargetDictionary","isBufferGeometry","morphAttributes","keys","length","morphAttribute","m","ml","name","String","push","morphTargets","console","error","raycast","raycaster","intersects","matrixWorld","boundingSphere","computeBoundingSphere","applyMatrix4","ray","intersectsSphere","invert","boundingBox","intersectsBox","intersection","index","position","attributes","morphPosition","morphTargetsRelative","uv","uv2","groups","drawRange","Array","isArray","i","il","group","groupMaterial","materialIndex","start","Math","max","end","min","count","j","jl","a","getX","b","c","checkBufferGeometryIntersection","faceIndex","floor","face","isGeometry","checkIntersection","object","pA","pB","pC","point","intersect","side","intersectTriangle","distance","origin","distanceTo","near","far","clone","fromBufferAttribute","morphInfluences","set","influence","addScaledVector","sub","add","isSkinnedMesh","skinning","boneTransform","getUV","normal","getNormal"],"sources":["/Users/sam/Documents/CakeProject/node_modules/three/src/objects/Mesh.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\n\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\n\nconst _tempA = new Vector3();\nconst _tempB = new Vector3();\nconst _tempC = new Vector3();\n\nconst _morphA = new Vector3();\nconst _morphB = new Vector3();\nconst _morphC = new Vector3();\n\nconst _uvA = new Vector2();\nconst _uvB = new Vector2();\nconst _uvC = new Vector2();\n\nconst _intersectionPoint = new Vector3();\nconst _intersectionPointWorld = new Vector3();\n\nfunction Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n\tthis.updateMorphTargets();\n\n}\n\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Mesh,\n\n\tisMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t// Check boundingBox before continuing\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\tlet intersection;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst uv = geometry.attributes.uv;\n\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t}\n\n} );\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst morphInfluences = object.morphTargetInfluences;\n\n\tif ( material.morphTargets && morphPosition && morphInfluences ) {\n\n\t\t_morphA.set( 0, 0, 0 );\n\t\t_morphB.set( 0, 0, 0 );\n\t\t_morphC.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\tconst influence = morphInfluences[ i ];\n\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_vA.add( _morphA );\n\t\t_vB.add( _morphB );\n\t\t_vC.add( _morphC );\n\n\t}\n\n\tif ( object.isSkinnedMesh && material.skinning ) {\n\n\t\tobject.boneTransform( a, _vA );\n\t\tobject.boneTransform( b, _vB );\n\t\tobject.boneTransform( c, _vC );\n\n\t}\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv2 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv2, a );\n\t\t\t_uvB.fromBufferAttribute( uv2, b );\n\t\t\t_uvC.fromBufferAttribute( uv2, c );\n\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nexport { Mesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}