{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/new Vector3();\n\nconst _vector2 = /*@__PURE__*/new Vector3();\n\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\nclass Plane {\n  constructor() {\n    let normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\n    let constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // normal is assumed to be normalized\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .projectPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .intersectLine() target is now required');\n      target = new Vector3();\n    }\n\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .coplanarPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nPlane.prototype.isPlane = true;\nexport { Plane };","map":{"version":3,"names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","constructor","normal","constant","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","undefined","console","warn","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals","clone","prototype","isPlane"],"sources":["/Users/sam/Documents/CakeProject/node_modules/three/src/math/Plane.js"],"sourcesContent":["import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nPlane.prototype.isPlane = true;\n\nexport { Plane };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}